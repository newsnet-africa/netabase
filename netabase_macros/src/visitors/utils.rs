use std::collections::HashMap;
use syn::{ExprClosure, Field, PathSegment, Token, Variant, punctuated::Punctuated};

use schema_finder::SchemaType;

/// Information about a validated schema
#[derive(Clone)]
pub struct SchemaInfo<'ast> {
    /// The schema type (struct or enum)
    pub schema_type: Option<SchemaType<'ast>>,
    /// Full path to the schema including module hierarchy
    pub path: Punctuated<PathSegment, Token![::]>,
    pub schema_key: Option<KeyType<'ast>>,
}

impl<'ast> SchemaInfo<'ast> {
    /// Create a new empty schema info
    pub fn new() -> Self {
        Self {
            schema_type: None,
            path: Punctuated::new(),
            schema_key: None,
        }
    }

    /// Check if this schema info is complete and valid
    pub fn is_valid(&self) -> bool {
        self.schema_type.is_some() && self.schema_key.is_some()
    }

    /// Get the schema name
    pub fn name(&self) -> Option<&syn::Ident> {
        self.schema_type.as_ref().map(|st| st.identity())
    }

    /// Get the full path as a string
    pub fn path_string(&self) -> String {
        self.path
            .iter()
            .map(|segment| segment.ident.to_string())
            .collect::<Vec<_>>()
            .join("::")
    }
}

impl<'ast> Default for SchemaInfo<'ast> {
    fn default() -> Self {
        Self::new()
    }
}

/// Information about a field key including its position
#[derive(Clone)]
pub struct FieldKeyInfo<'ast> {
    pub field: &'ast Field,
    pub index: Option<usize>, // For tuple variants, this is the field index
}

/// General key information wrapper
#[derive(Clone)]
pub struct KeyInfo<'ast> {
    pub key_type: KeyType<'ast>,
    pub validation_errors: Vec<String>,
}

impl<'ast> KeyInfo<'ast> {
    pub fn new(key_type: KeyType<'ast>) -> Self {
        Self {
            key_type,
            validation_errors: Vec::new(),
        }
    }

    pub fn with_errors(key_type: KeyType<'ast>, errors: Vec<String>) -> Self {
        Self {
            key_type,
            validation_errors: errors,
        }
    }

    pub fn is_valid(&self) -> bool {
        self.validation_errors.is_empty()
    }
}

/// Type of key used by a schema
#[derive(Clone)]
pub enum KeyType<'ast> {
    /// Keys are individual fields marked with #[key]
    FieldKeys(HashMap<Option<&'ast Variant>, Vec<FieldKeyInfo<'ast>>>),
    /// Key is a closure defined on the schema itself
    SchemaKey(&'ast ExprClosure),
    /// Key is generated by a function reference
    KeyFunction(String),
}

impl<'ast> KeyType<'ast> {
    /// Check if this is a field key type
    pub fn is_field_keys(&self) -> bool {
        matches!(self, KeyType::FieldKeys(_))
    }

    /// Check if this is a schema key type
    pub fn is_schema_key(&self) -> bool {
        matches!(self, KeyType::SchemaKey(_))
    }

    /// Check if this is a key function type
    pub fn is_key_function(&self) -> bool {
        matches!(self, KeyType::KeyFunction(_))
    }

    /// Get field keys if this is a field key type
    pub fn as_field_keys(
        &self,
    ) -> Option<&HashMap<Option<&'ast Variant>, Vec<FieldKeyInfo<'ast>>>> {
        match self {
            KeyType::FieldKeys(fields) => Some(fields),
            _ => None,
        }
    }

    /// Get schema key if this is a schema key type
    pub fn as_schema_key(&self) -> Option<&'ast ExprClosure> {
        match self {
            KeyType::SchemaKey(closure) => Some(closure),
            _ => None,
        }
    }

    /// Get key function if this is a key function type
    pub fn as_key_function(&self) -> Option<&str> {
        match self {
            KeyType::KeyFunction(func_name) => Some(func_name),
            _ => None,
        }
    }

    /// Get the generation type for this key type
    pub fn generation_type(&self) -> Result<&str, &'static str> {
        match self {
            KeyType::FieldKeys(_) => Ok("field_keys"),
            KeyType::SchemaKey(_) => Ok("schema_key"),
            KeyType::KeyFunction(_) => Ok("key_function"),
        }
    }

    /// Check if this key type is valid
    pub fn is_valid(&self) -> bool {
        match self {
            KeyType::FieldKeys(fields) => !fields.is_empty(),
            KeyType::SchemaKey(_) => true,
            KeyType::KeyFunction(func_name) => !func_name.is_empty(),
        }
    }
}

pub(crate) mod schema_finder {
    use std::collections::HashMap;

    use syn::{
        Attribute, Field, Fields, Generics, Ident, Item, ItemEnum, ItemStruct, Variant, Visibility,
        punctuated::Punctuated, spanned::Spanned, token::Comma,
    };

    #[derive(Clone, Copy)]
    pub enum SchemaType<'ast> {
        Struct(&'ast ItemStruct),
        Enum(&'ast ItemEnum),
    }

    impl<'ast> SchemaType<'ast> {
        pub fn attributes<'b>(&'b self) -> &'ast Vec<Attribute> {
            match self {
                SchemaType::Struct(item_struct) => &item_struct.attrs,
                SchemaType::Enum(item_enum) => &item_enum.attrs,
            }
        }

        pub fn visibility<'b>(&'b self) -> &'ast Visibility {
            match self {
                SchemaType::Struct(item_struct) => &item_struct.vis,
                SchemaType::Enum(item_enum) => &item_enum.vis,
            }
        }
        pub fn identity<'b>(&'b self) -> &'ast Ident {
            match self {
                SchemaType::Struct(item_struct) => &item_struct.ident,
                SchemaType::Enum(item_enum) => &item_enum.ident,
            }
        }

        pub fn generics<'b>(&'b self) -> &'ast Generics {
            match self {
                SchemaType::Struct(item_struct) => &item_struct.generics,
                SchemaType::Enum(item_enum) => &item_enum.generics,
            }
        }

        pub fn variants<'b>(&'b self) -> Option<&'ast Punctuated<Variant, Comma>> {
            match self {
                SchemaType::Struct(_) => None,
                SchemaType::Enum(item_enum) => Some(&item_enum.variants),
            }
        }

        pub fn fields<'b>(&'b self) -> HashMap<Option<&'ast Variant>, &'ast Fields> {
            match self {
                SchemaType::Struct(item_struct) => {
                    let mut res: HashMap<Option<&'ast Variant>, &'ast syn::Fields> = HashMap::new();
                    res.insert(None, &item_struct.fields);
                    res
                }
                SchemaType::Enum(item_enum) => {
                    let mut res: HashMap<Option<&Variant>, &syn::Fields> = HashMap::new();
                    item_enum.variants.iter().for_each(|v| {
                        res.insert(Some(v), &v.fields);
                    });
                    res
                }
            }
        }
    }

    impl<'a> TryFrom<&'a Item> for SchemaType<'a> {
        type Error = syn::Error;

        fn try_from(value: &'a Item) -> Result<Self, Self::Error> {
            match value {
                Item::Enum(item_enum) => Ok(SchemaType::Enum(item_enum)),
                Item::Struct(item_struct) => Ok(SchemaType::Struct(item_struct)),
                _ => Err(syn::Error::new(
                    value.span(),
                    "Schema can only be an Enum or a Struct",
                )),
            }
        }
    }
}

pub(crate) mod schema_validator {
    use crate::visitors::utils::schema_finder::SchemaType;

    pub fn contains_netabase_derive<'a>(schema_type: &SchemaType<'a>) -> bool {
        schema_type
            .attributes()
            .iter()
            .any(|att| att.path().is_ident("NetabaseSchema"))
    }
}

pub mod key_finder {
    use crate::visitors::utils::{FieldKeyInfo, KeyType};
    use std::collections::HashMap;
    use syn::{Expr, Meta};

    use crate::visitors::utils::schema_finder::SchemaType;

    pub fn get_schema_field_keys<'ast: 'b, 'b>(schema: &'b SchemaType<'ast>) -> KeyType<'ast> {
        let mut key_map: HashMap<Option<&syn::Variant>, Vec<FieldKeyInfo<'_>>> = HashMap::new();

        for (var, fields) in schema.fields().iter() {
            let key_fields: Vec<FieldKeyInfo> = fields
                .iter()
                .filter_map(|field| {
                    if field.attrs.iter().any(|attr| attr.path().is_ident("key")) {
                        Some(FieldKeyInfo { field, index: None })
                    } else {
                        None
                    }
                })
                .collect();

            if key_fields.is_empty() {
                if var.is_some() {
                    panic!("Every Variant needs a key");
                } else {
                    panic!("Fielded structs need a key field");
                }
            }

            key_map.insert(*var, key_fields);
        }

        KeyType::FieldKeys(key_map)
    }

    pub fn get_schema_outer_key<'ast: 'b, 'b>(
        schema: &'b SchemaType<'ast>,
    ) -> Option<KeyType<'ast>> {
        schema.attributes().iter().find_map(|attr| {
            if attr.path().is_ident("key") {
                // Use newer syn API for parsing attributes
                if let Meta::NameValue(name_value) = &attr.meta {
                    if let Expr::Closure(closure) = &name_value.value {
                        return Some(KeyType::SchemaKey(closure));
                    }
                }
            }
            None
        })
    }
}
