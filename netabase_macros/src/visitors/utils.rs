use quote::ToTokens;
use std::collections::HashMap;
use syn::{ExprClosure, Field, PathSegment, Token, Variant, punctuated::Punctuated};

use crate::visitors::schema_finder::SchemaType;

/// Information about a validated schema
#[derive(Clone)]
pub struct SchemaInfo<'ast> {
    /// The schema type (struct or enum)
    pub schema_type: Option<SchemaType<'ast>>,
    /// Full path to the schema including module hierarchy
    pub path: Punctuated<PathSegment, Token![::]>,
    /// Key information for the schema
    pub schema_key: Option<KeyInfo<'ast>>,
}

impl<'ast> SchemaInfo<'ast> {
    /// Create a new empty schema info
    pub fn new() -> Self {
        Self {
            schema_type: None,
            path: Punctuated::new(),
            schema_key: None,
        }
    }

    /// Check if this schema info is complete and valid
    pub fn is_valid(&self) -> bool {
        self.schema_type.is_some() && self.schema_key.is_some()
    }

    /// Get the schema name
    pub fn name(&self) -> Option<&syn::Ident> {
        self.schema_type.as_ref().map(|st| st.identity())
    }

    /// Get the full path as a string
    pub fn path_string(&self) -> String {
        self.path
            .iter()
            .map(|segment| segment.ident.to_string())
            .collect::<Vec<_>>()
            .join("::")
    }
}

impl<'ast> Default for SchemaInfo<'ast> {
    fn default() -> Self {
        Self::new()
    }
}

/// Information about a field key including its position
#[derive(Clone)]
pub struct FieldKeyInfo<'ast> {
    pub field: &'ast Field,
    pub index: Option<usize>, // For tuple variants, this is the field index
}

/// Type of key used by a schema
#[derive(Clone)]
pub enum KeyType<'ast> {
    /// Keys are individual fields marked with #[key]
    FieldKeys(HashMap<Option<&'ast Variant>, FieldKeyInfo<'ast>>),
    /// Key is a closure defined on the schema itself
    SchemaKey(&'ast ExprClosure),
    /// Key is generated by a function reference
    KeyFunction(String),
}

impl<'ast> KeyType<'ast> {
    /// Check if this is a field key type
    pub fn is_field_keys(&self) -> bool {
        matches!(self, KeyType::FieldKeys(_))
    }

    /// Check if this is a schema key type
    pub fn is_schema_key(&self) -> bool {
        matches!(self, KeyType::SchemaKey(_))
    }

    /// Check if this is a key function type
    pub fn is_key_function(&self) -> bool {
        matches!(self, KeyType::KeyFunction(_))
    }

    /// Get field keys if this is a field key type
    pub fn as_field_keys(&self) -> Option<&HashMap<Option<&'ast Variant>, FieldKeyInfo<'ast>>> {
        match self {
            KeyType::FieldKeys(fields) => Some(fields),
            _ => None,
        }
    }

    /// Get schema key if this is a schema key type
    pub fn as_schema_key(&self) -> Option<&'ast ExprClosure> {
        match self {
            KeyType::SchemaKey(closure) => Some(closure),
            _ => None,
        }
    }

    /// Get key function if this is a key function type
    pub fn as_key_function(&self) -> Option<&str> {
        match self {
            KeyType::KeyFunction(func_name) => Some(func_name),
            _ => None,
        }
    }
}

impl ToTokens for KeyType<'_> {
    fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {
        match self {
            KeyType::FieldKeys(field_map) => {
                let field_tokens: Vec<proc_macro2::TokenStream> = field_map
                    .iter()
                    .filter_map(|(variant_opt, field_info)| {
                        let field = field_info.field;
                        if let Some(variant) = variant_opt {
                            Some(quote::quote! {
                                stringify!(#variant: #field)
                            })
                        } else {
                            Some(quote::quote! {
                                stringify!(#field)
                            })
                        }
                    })
                    .collect();

                tokens.extend(quote::quote! {
                    #(#field_tokens)*
                });
            }
            KeyType::SchemaKey(closure) => {
                closure.to_tokens(tokens);
            }
            KeyType::KeyFunction(func_name) => {
                tokens.extend(quote::quote! {
                    stringify!(#func_name)
                });
            }
        }
    }
}

/// Information about keys for a schema
#[derive(Clone, Default)]
pub struct KeyInfo<'ast> {
    /// The type of key generation to use
    pub generation_type: Option<KeyType<'ast>>,
}

impl<'ast> KeyInfo<'ast> {
    /// Create a new empty key info
    pub fn new() -> Self {
        Self::default()
    }

    /// Create key info with a specific generation type
    pub fn with_generation_type(generation_type: KeyType<'ast>) -> Self {
        Self {
            generation_type: Some(generation_type),
        }
    }

    /// Check if this key info is valid (has a generation type)
    pub fn is_valid(&self) -> bool {
        self.generation_type.is_some()
    }

    /// Get the generation type
    pub fn generation_type(&self) -> Option<&KeyType<'ast>> {
        self.generation_type.as_ref()
    }

    /// Check if this uses field keys
    pub fn uses_field_keys(&self) -> bool {
        matches!(self.generation_type, Some(KeyType::FieldKeys(_)))
    }

    /// Check if this uses a schema key
    pub fn uses_schema_key(&self) -> bool {
        matches!(self.generation_type, Some(KeyType::SchemaKey(_)))
    }

    /// Check if this uses a key function
    pub fn uses_key_function(&self) -> bool {
        matches!(self.generation_type, Some(KeyType::KeyFunction(_)))
    }
}

/// Builder pattern for creating SchemaInfo
pub struct SchemaInfoBuilder<'ast> {
    info: SchemaInfo<'ast>,
}

impl<'ast> SchemaInfoBuilder<'ast> {
    /// Create a new builder
    pub fn new() -> Self {
        Self {
            info: SchemaInfo::new(),
        }
    }

    /// Set the schema type
    pub fn with_schema_type(mut self, schema_type: SchemaType<'ast>) -> Self {
        self.info.schema_type = Some(schema_type);
        self
    }

    /// Set the path
    pub fn with_path(mut self, path: Punctuated<PathSegment, Token![::]>) -> Self {
        self.info.path = path;
        self
    }

    /// Set the key info
    pub fn with_key_info(mut self, key_info: KeyInfo<'ast>) -> Self {
        self.info.schema_key = Some(key_info);
        self
    }

    /// Build the final SchemaInfo
    pub fn build(self) -> SchemaInfo<'ast> {
        self.info
    }
}

impl<'ast> Default for SchemaInfoBuilder<'ast> {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use syn::parse_quote;

    #[test]
    fn test_schema_info_creation() {
        let info = SchemaInfo::new();
        assert!(!info.is_valid());
        assert!(info.name().is_none());
    }

    #[test]
    fn test_key_info_creation() {
        let key_info = KeyInfo::new();
        assert!(!key_info.is_valid());

        let field_keys = HashMap::new();
        let key_info_with_type = KeyInfo::with_generation_type(KeyType::FieldKeys(field_keys));
        assert!(key_info_with_type.is_valid());
        assert!(key_info_with_type.uses_field_keys());
    }

    #[test]
    fn test_schema_info_builder() {
        let item: syn::Item = parse_quote! {
            struct TestSchema {
                id: u64,
            }
        };

        let schema_type = SchemaType::try_from(&item).unwrap();
        let path: Punctuated<PathSegment, Token![::]> = parse_quote!(test::TestSchema);
        let key_info = KeyInfo::new();

        let info = SchemaInfoBuilder::new()
            .with_schema_type(schema_type)
            .with_path(path)
            .with_key_info(key_info)
            .build();

        assert!(info.schema_type.is_some());
        assert_eq!(info.path.len(), 2);
    }
}
