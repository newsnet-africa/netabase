# NetabaseSchema Trait Implementations

This document describes the comprehensive trait implementations generated by the `#[derive(NetabaseSchema)]` macro using syn structures instead of the quote! macro.

## Overview

The `NetabaseSchema` derive macro generates multiple trait implementations and utility functions to enable seamless integration with Kademlia distributed hash tables. All code generation is done using syn AST structures for precise control over the generated code.

## Generated Components

### 1. Key Type Structure

For each schema type `T`, a corresponding key type `TKey` is generated:

```rust
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct TKey(pub String);
```

**Implementation Details:**
- Generated using `syn::ItemStruct` with `syn::Fields::Unnamed`
- Automatically derives standard traits for key operations
- Uses `String` as the underlying key storage for Kademlia compatibility

### 2. Key Type Utility Methods

```rust
impl TKey {
    pub fn new(value: String) -> Self
    pub fn as_str(&self) -> &str
    pub fn into_string(self) -> String
}
```

**Implementation Details:**
- Generated using `syn::ItemImpl` with `trait_: None`
- Each method created as `syn::ImplItem::Fn(syn::ImplItemFn)`
- Function signatures created with `syn::parse_quote!`

### 3. NetabaseSchemaKey Trait Implementation

```rust
impl NetabaseSchemaKey for TKey {
    fn generate_key() -> Self {
        // Timestamp + hash-based key generation
        use std::time::{SystemTime, UNIX_EPOCH};
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos();

        let mut hasher = DefaultHasher::new();
        timestamp.hash(&mut hasher);
        let hash = hasher.finish();

        Self(format!("{}_{}", timestamp, hash))
    }
}
```

**Implementation Details:**
- Generated using `syn::ItemImpl` with trait specification
- Provides unique key generation using timestamp + hash
- Ensures distributed uniqueness suitable for Kademlia networks

### 4. Bincode Serialization Support

```rust
impl bincode::Encode for TKey {
    fn encode<E: bincode::enc::Encoder>(
        &self,
        encoder: &mut E,
    ) -> Result<(), bincode::error::EncodeError> {
        self.0.encode(encoder)
    }
}

impl bincode::Decode<()> for TKey {
    fn decode<D: bincode::de::Decoder>(
        decoder: &mut D,
    ) -> Result<Self, bincode::error::DecodeError> {
        let value = String::decode(decoder)?;
        Ok(Self(value))
    }
}
```

**Implementation Details:**
- Generated as separate `syn::ItemImpl` structures
- Delegates to underlying String serialization
- Essential for Kademlia record storage

### 5. Conversion From libp2p Types

```rust
impl From<libp2p::kad::Record> for TKey {
    fn from(record: libp2p::kad::Record) -> Self {
        let key_bytes = record.key.to_vec();
        let key_string = String::from_utf8(key_bytes)
            .unwrap_or_else(|e| format!("invalid_utf8_{}", e.utf8_error().valid_up_to()));
        Self(key_string)
    }
}

impl From<crate::database::wrappers::RecordWrapper> for TKey {
    fn from(wrapper: crate::database::wrappers::RecordWrapper) -> Self {
        match wrapper {
            crate::database::wrappers::RecordWrapper::KadRecord(record) => {
                Self::from(record)
            }
        }
    }
}
```

**Implementation Details:**
- Handles UTF-8 conversion with graceful fallback
- Supports both direct libp2p records and wrapped types
- Generated using pattern matching for extensibility

### 6. NetabaseSchema Trait Implementation

```rust
impl NetabaseSchema for T {
    type Key = TKey;
    
    fn key(&self) -> &Self::Key {
        // Generated based on key field analysis
    }
}
```

**Key Extraction Logic:**

The `key()` method implementation varies based on the schema structure:

#### For Structs:
- **Named fields with #[key]**: `format!("{}", self.field_name)`
- **Unnamed fields with #[key]**: `format!("{:?}", self.0)`
- **No key fields**: Returns empty key

#### For Enums:
- **Each variant**: Pattern matches and extracts from the variant's key field
- **Named variant fields**: `Self::Variant { key_field, .. } => format!("{}", key_field)`
- **Unnamed variant fields**: `Self::Variant(key_value, ..) => format!("{}", key_value)`
- **Unit variants**: Uses variant name as key

**Implementation Details:**
- Generated using `generate_key_extraction_block()` function
- Creates match expressions using `syn::parse_quote!`
- Uses `std::sync::OnceLock` for key caching (performance optimization)

### 7. Schema Type Conversions

```rust
impl From<libp2p::kad::Record> for T {
    fn from(record: libp2p::kad::Record) -> Self {
        let data = record.value;
        bincode::decode_from_slice(&data, bincode::config::standard())
            .map(|(value, _)| value)
            .unwrap_or_else(|_| {
                panic!("Failed to deserialize {} from libp2p record", stringify!(T))
            })
    }
}

impl From<crate::database::wrappers::RecordWrapper> for T {
    fn from(wrapper: crate::database::wrappers::RecordWrapper) -> Self {
        match wrapper {
            crate::database::wrappers::RecordWrapper::KadRecord(record) => {
                Self::from(record)
            }
        }
    }
}
```

### 8. Kademlia Integration Utilities

```rust
impl T {
    /// Convert this schema item to a libp2p::kad::Record
    pub fn to_kad_record(&self) -> Result<libp2p::kad::Record, bincode::error::EncodeError> {
        let key_bytes = self.key().as_str().as_bytes().to_vec();
        let key = libp2p::kad::RecordKey::new(&key_bytes);
        let value = bincode::encode_to_vec(self, bincode::config::standard())?;
        
        Ok(libp2p::kad::Record {
            key,
            value,
            publisher: None,
            expires: None,
        })
    }

    /// Get the Kademlia key for this schema item
    pub fn kad_key(&self) -> libp2p::kad::RecordKey {
        let key_bytes = self.key().as_str().as_bytes().to_vec();
        libp2p::kad::RecordKey::new(&key_bytes)
    }
}
```

## Technical Implementation Details

### Syn Structure Usage

The implementation exclusively uses syn structures for code generation:

1. **ItemStruct**: For generating key type definitions
2. **ItemImpl**: For trait implementations and utility methods
3. **ImplItemFn**: For individual method implementations
4. **ImplItemType**: For associated type declarations
5. **syn::parse_quote!**: For generating method bodies and complex expressions

### Key Extraction Strategy

The macro analyzes each schema item to determine key extraction:

1. **Field Analysis**: Uses visitor pattern to find `#[key]` attributes
2. **Validation**: Ensures exactly one key field per struct/enum variant
3. **Code Generation**: Creates appropriate match arms or field access patterns
4. **Caching**: Uses `std::sync::OnceLock` for performance optimization

### Error Handling

- **Compilation Errors**: Generated for invalid key configurations
- **Runtime Errors**: Graceful handling of serialization/deserialization failures
- **UTF-8 Conversion**: Fallback strategies for invalid byte sequences

### Performance Considerations

- **Lazy Key Computation**: Keys are computed once and cached
- **Zero-Copy Where Possible**: Direct reference returns for key access
- **Efficient Serialization**: Delegates to bincode for optimal performance

## Usage Examples

### Basic Struct Usage

```rust
#[derive(NetabaseSchema, Encode, Decode)]
struct User {
    #[key]
    id: String,
    name: String,
}

let user = User { id: "123".to_string(), name: "Alice".to_string() };
let record = user.to_kad_record()?;
let recovered = User::from(record);
```

### Enum Usage

```rust
#[derive(NetabaseSchema, Encode, Decode)]
enum Document {
    Text { #[key] hash: String, content: String },
    Image { #[key] hash: String, data: Vec<u8> },
}
```

### Key Generation

```rust
let new_key = UserKey::generate_key();
let custom_key = UserKey::new("custom_id".to_string());
```

## Integration with Kademlia

The generated implementations provide seamless integration with libp2p's Kademlia DHT:

1. **Record Storage**: Direct conversion to/from `libp2p::kad::Record`
2. **Key Compatibility**: String-based keys compatible with Kademlia routing
3. **Serialization**: Efficient bincode serialization for network transport
4. **Unique Keys**: Timestamp + hash generation for distributed uniqueness

## Validation Rules

The macro enforces these validation rules:

1. **Structs**: Must have exactly one `#[key]` field
2. **Enums**: Each variant must have exactly one `#[key]` field, OR the enum must have a top-level `#[key = closure]` attribute
3. **Key Fields**: Must be compatible with `format!()` or `Debug` formatting
4. **Trait Bounds**: Schema types must implement `Clone`, `Encode`, and `Decode`

This implementation provides a robust, type-safe foundation for distributed data storage using Kademlia DHTs while maintaining full compatibility with libp2p networking protocols.